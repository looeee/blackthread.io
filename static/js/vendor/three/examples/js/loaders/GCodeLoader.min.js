"use strict";THREE.GCodeLoader=function(e){this.manager=void 0!==e?e:THREE.DefaultLoadingManager,this.splitLayer=!1},THREE.GCodeLoader.prototype.load=function(e,r,t,o){var a=this;new THREE.FileLoader(a.manager).load(e,function(e){r(a.parse(e))},t,o)},THREE.GCodeLoader.prototype.parse=function(e){var r={x:0,y:0,z:0,e:0,f:0,extruding:!1,relative:!1},t=[],o=void 0,a=new THREE.LineBasicMaterial({color:16711680});a.name="path";var i=new THREE.LineBasicMaterial({color:65280});function n(e){o={vertex:[],pathVertex:[],z:e.z},t.push(o)}function d(e,t){return r.relative?t:t-e}function s(e,t){return r.relative?e+t:t}i.name="extruded";for(var v,l,u=e.replace(/;.+/g,"").split("\n"),p=0;p<u.length;p++){var f=u[p].split(" "),E=f[0].toUpperCase(),x={};if(f.splice(1).forEach(function(e){if(void 0!==e[0]){var r=e[0].toLowerCase(),t=parseFloat(e.substring(1));x[r]=t}}),"G0"===E||"G1"===E){var c={x:void 0!==x.x?s(r.x,x.x):r.x,y:void 0!==x.y?s(r.y,x.y):r.y,z:void 0!==x.z?s(r.z,x.z):r.z,e:void 0!==x.e?s(r.e,x.e):r.e,f:void 0!==x.f?s(r.f,x.f):r.f};d(r.e,c.e)>0&&(c.extruding=d(r.e,c.e)>0,void 0!=o&&c.z==o.z||n(c)),v=r,l=c,void 0===o&&n(v),c.extruding?(o.vertex.push(v.x,v.y,v.z),o.vertex.push(l.x,l.y,l.z)):(o.pathVertex.push(v.x,v.y,v.z),o.pathVertex.push(l.x,l.y,l.z)),r=c}else if("G2"===E||"G3"===E)console.warn("THREE.GCodeLoader: Arc command not supported");else if("G90"===E)r.relative=!1;else if("G91"===E)r.relative=!0;else if("G92"===E){(c=r).x=void 0!==x.x?x.x:c.x,c.y=void 0!==x.y?x.y:c.y,c.z=void 0!==x.z?x.z:c.z,c.e=void 0!==x.e?x.e:c.e,r=c}else console.warn("THREE.GCodeLoader: Command not supported:"+E)}function h(e,r){var t=new THREE.BufferGeometry;t.addAttribute("position",new THREE.Float32BufferAttribute(e,3));var o=new THREE.LineSegments(t,r?i:a);o.name="layer"+p,y.add(o)}var y=new THREE.Group;if(y.name="gcode",this.splitLayer)for(p=0;p<t.length;p++){h((G=t[p]).vertex,!0),h(G.pathVertex,!1)}else{var z=[],g=[];for(p=0;p<t.length;p++){var G=t[p];z=z.concat(G.vertex),g=g.concat(G.pathVertex)}h(z,!0),h(g,!1)}return y.quaternion.setFromEuler(new THREE.Euler(-Math.PI/2,0,0)),y};