THREE.PCDLoader=function(e){this.manager=void 0!==e?e:THREE.DefaultLoadingManager,this.littleEndian=!0},THREE.PCDLoader.prototype={constructor:THREE.PCDLoader,load:function(e,t,i,r){var n=this,s=new THREE.FileLoader(n.manager);s.setResponseType("arraybuffer"),s.load(e,function(i){t(n.parse(i,e))},i,r)},parse:function(e,t){var i=THREE.LoaderUtils.decodeText(e),r=function(e){var t={},i=e.search(/[\r\n]DATA\s(\S*)\s/i),r=/[\r\n]DATA\s(\S*)\s/i.exec(e.substr(i-1));if(t.data=r[1],t.headerLen=r[0].length+i,t.str=e.substr(0,t.headerLen),t.str=t.str.replace(/\#.*/gi,""),t.version=/VERSION (.*)/i.exec(t.str),t.fields=/FIELDS (.*)/i.exec(t.str),t.size=/SIZE (.*)/i.exec(t.str),t.type=/TYPE (.*)/i.exec(t.str),t.count=/COUNT (.*)/i.exec(t.str),t.width=/WIDTH (.*)/i.exec(t.str),t.height=/HEIGHT (.*)/i.exec(t.str),t.viewpoint=/VIEWPOINT (.*)/i.exec(t.str),t.points=/POINTS (.*)/i.exec(t.str),null!==t.version&&(t.version=parseFloat(t.version[1])),null!==t.fields&&(t.fields=t.fields[1].split(" ")),null!==t.type&&(t.type=t.type[1].split(" ")),null!==t.width&&(t.width=parseInt(t.width[1])),null!==t.height&&(t.height=parseInt(t.height[1])),null!==t.viewpoint&&(t.viewpoint=t.viewpoint[1]),null!==t.points&&(t.points=parseInt(t.points[1],10)),null===t.points&&(t.points=t.width*t.height),null!==t.size&&(t.size=t.size[1].split(" ").map(function(e){return parseInt(e,10)})),null!==t.count)t.count=t.count[1].split(" ").map(function(e){return parseInt(e,10)});else{t.count=[];for(var n=0,s=t.fields.length;n<s;n++)t.count.push(1)}t.offset={};var a=0;for(n=0,s=t.fields.length;n<s;n++)"ascii"===t.data?t.offset[t.fields[n]]=n:(t.offset[t.fields[n]]=a,a+=t.size[n]);return t.rowSize=a,t}(i),n=[],s=[],a=[];if("ascii"===r.data)for(var o=r.offset,l=i.substr(r.headerLen).split("\n"),p=0,u=l.length;p<u;p++){var d=l[p].split(" ");if(void 0!==o.x&&(n.push(parseFloat(d[o.x])),n.push(parseFloat(d[o.y])),n.push(parseFloat(d[o.z]))),void 0!==o.rgb){var h=new Float32Array([parseFloat(d[o.rgb])]),f=new DataView(h.buffer,0);a.push(f.getUint8(0)/255),a.push(f.getUint8(1)/255),a.push(f.getUint8(2)/255)}void 0!==o.normal_x&&(s.push(parseFloat(d[o.normal_x])),s.push(parseFloat(d[o.normal_y])),s.push(parseFloat(d[o.normal_z])))}if("binary_compressed"!==r.data){if("binary"===r.data){f=new DataView(e,r.headerLen),o=r.offset,p=0;for(var E=0;p<r.points;p++,E+=r.rowSize)void 0!==o.x&&(n.push(f.getFloat32(E+o.x,this.littleEndian)),n.push(f.getFloat32(E+o.y,this.littleEndian)),n.push(f.getFloat32(E+o.z,this.littleEndian))),void 0!==o.rgb&&(a.push(f.getUint8(E+o.rgb+0)/255),a.push(f.getUint8(E+o.rgb+1)/255),a.push(f.getUint8(E+o.rgb+2)/255)),void 0!==o.normal_x&&(s.push(f.getFloat32(E+o.normal_x,this.littleEndian)),s.push(f.getFloat32(E+o.normal_y,this.littleEndian)),s.push(f.getFloat32(E+o.normal_z,this.littleEndian)))}var c=new THREE.BufferGeometry;n.length>0&&c.addAttribute("position",new THREE.Float32BufferAttribute(n,3)),s.length>0&&c.addAttribute("normal",new THREE.Float32BufferAttribute(s,3)),a.length>0&&c.addAttribute("color",new THREE.Float32BufferAttribute(a,3)),c.computeBoundingSphere();var g=new THREE.PointsMaterial({size:.005});a.length>0?g.vertexColors=!0:g.color.setHex(16777215*Math.random());var v=new THREE.Points(c,g),w=t.split("").reverse().join("");return w=(w=/([^\/]*)/.exec(w))[1].split("").reverse().join(""),v.name=w,v}console.error("THREE.PCDLoader: binary_compressed files are not supported")}};